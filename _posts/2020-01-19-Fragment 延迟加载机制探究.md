---
layout: post
title: 'Fragment 在 ViewPager 中延迟加载机制探究 '
subtitle: ''
date: 2020-01-19
categories: 技术
cover: 'https://goss.veer.com/creative/vcg/veer/800water/veer-344738821.jpg'
tags: 技术分享
---

### ViewPager加载机制

​		ViewPager的基础设计中，为了保证流畅性，强制使用了预加载，在默认情况下，ViewPager会默认加载当前页面左右的view。在使用ViewPager加载Fragment场景下，ViewPager 也会对当前Fragment的左右Fragment进行预加载，这种预加载往往是中过度加载。

![Fragment生命周期](https://user-gold-cdn.xitu.io/2019/12/29/16f50ae1500c7d1d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

* 延迟生命周期的开始（生命周期未开始）
* 延迟数据加载（生命周期中拦截）



#### 1.延迟开始生命周期（目前himalaya 项目中使用）

延迟生命周期，采用的是继承源码重写相关函数的方式实现。

重写 PagerAdapter.instantiateItem()和destroyItem(),拦截instantiateItem中被add到ViewPager的Fragment,自己管理这些Fragment 的 add 和 detach来实现Fragment 延迟生命周期的开始

LazyFragmentPagerAdapter

```java
public abstract class LazyFragmentPagerAdapter extends LazyPagerAdapter<Fragment> {

    @Override
    public Object instantiateItem(ViewGroup container, int position) {
        if (mCurTransaction == null) {
            mCurTransaction = mFragmentManager.beginTransaction();
        }

        final long itemId = getItemId(position);

        // Do we already have this fragment?
        String name = makeFragmentName(container.getId(), itemId);
        Fragment fragment = mFragmentManager.findFragmentByTag(name);
        if (fragment != null) {
            if (DEBUG)
                Log.v(TAG, "Attaching item #" + itemId + ": f=" + fragment);
            mCurTransaction.attach(fragment);
        } else {
            fragment = getItem(container, position);
            if (fragment instanceof Laziable) {
                if (DEBUG)
                    Log.v(TAG, "add LazyItem #" + position + ": f=" + fragment);
                mLazyItems.put(position, fragment);
            } else {
                mCurTransaction.add(container.getId(), fragment, name);
            }
        }
        if (fragment != getCurrentItem()) {
            fragment.setMenuVisibility(false);
            fragment.setUserVisibleHint(false);
        }

        return fragment;
    }

    @Override
    public void destroyItem(ViewGroup container, int position, Object object) {
        if (mCurTransaction == null) {
            mCurTransaction = mFragmentManager.beginTransaction();
        }
        if (DEBUG)
            Log.v(TAG, "Detaching item #" + getItemId(position) + ": f=" + object + " v=" + ((Fragment) object).getView());

        final long itemId = getItemId(position);
        String name = makeFragmentName(container.getId(), itemId);
        if (mFragmentManager.findFragmentByTag(name) == null) {
            mCurTransaction.detach((Fragment) object);
        } else {
            mLazyItems.remove(position);
        }
    }

    @Override
    public Fragment addLazyItem(ViewGroup container, int position) {
        Fragment fragment = mLazyItems.get(position);
        if (DEBUG)
            Log.v(TAG, "getLazyItem #" +position+ ": f=" + fragment);
        if (fragment == null)
            return null;

        final long itemId = getItemId(position);
        String name = makeFragmentName(container.getId(), itemId);
        if (mFragmentManager.findFragmentByTag(name) == null) {
            if (mCurTransaction == null) {
                mCurTransaction = mFragmentManager.beginTransaction();
            }
            mCurTransaction.add(container.getId(), fragment, name);
            mLazyItems.remove(position);
            if (DEBUG)
                Log.v(TAG, "addFragment #" +position+ ": f=" + fragment);
        }
        return fragment;
    }

}
```

LazyViewPager

```java
public class LazyViewPager extends ViewPager {
    @Override
    protected void onPageScrolled(int position, float offset, int offsetPixels) {
        if (mLazyPagerAdapter != null) {
            if (getCurrentItem() == position) {
                int lazyPosition = position + 1;
                if (offset >= mInitLazyItemOffset && mLazyPagerAdapter.isLazyItem(lazyPosition)) {
                    mLazyPagerAdapter.startUpdate(this);
                    mLazyPagerAdapter.addLazyItem(this, lazyPosition);
                    mLazyPagerAdapter.finishUpdate(this);
                }
            } else if (getCurrentItem() > position) {
                int lazyPosition = position;
                if (1 - offset >= mInitLazyItemOffset && mLazyPagerAdapter.isLazyItem(lazyPosition)) {
                    mLazyPagerAdapter.startUpdate(this);
                    mLazyPagerAdapter.addLazyItem(this, lazyPosition);
                    mLazyPagerAdapter.finishUpdate(this);
                }
            }
        }
        super.onPageScrolled(position, offset, offsetPixels);
    }
}
```

####2.延迟数据加载（生命周期中拦截）

从上面的fragment的生命周期可以看出，fragment一旦被attach到父容器中，就会执行生命周期，一直到onresume











> 参考文档：https://juejin.im/post/5e085dafe51d45580769a1eb